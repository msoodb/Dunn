
# SWEET32


1. Step 1: Identify a Vulnerable Target
    Use a tool like SSL Labs Server Test or nmap to check the server's cipher suite.
```sh
        nmap --script ssl-enum-ciphers -p 443 <target-ip>
```
    Look for the presence of 3DES (e.g., TLS_RSA_WITH_3DES_EDE_CBC_SHA).

2. Step 2: Establish a Long-lived Connection
    Open a long-lived HTTPS connection to the target, such as downloading a large file or transferring significant data.
    Alternatively, simulate a session that repeatedly sends encrypted cookies or tokens.

3. Step 3: Capture Traffic
    Use tcpdump or Wireshark to capture the encrypted TLS traffic between the client and the server.
    tcpdump -i eth0 port 443 -w sweet32.pcap

4. Step 4: Inject Known Plaintext

    Control or predict some parts of the plaintext (e.g., HTTP cookies, session tokens) to make traffic analysis easier.

5. Step 5: Analyze for Block Collisions

    Use a script to detect repeated ciphertext blocks in the captured traffic.
    PoC scripts available online (e.g., GitHub repos) can automate this. Example repositories:
        Practical SWEET32 attack scripts (search for SWEET32 PoC)
        Scripts that calculate the probability of collisions from encrypted blocks.

6. Step 6: Exploit the Collisions

    Once repeated ciphertext blocks are identified, apply cryptanalysis techniques to recover the plaintext:
        Use a statistical or brute-force approach to reconstruct the original plaintext based on known patterns (e.g., cookies, padding).

Example SWEET32 PoC Script

Here is a high-level Python script example for detecting block collisions:

```python
from scapy.all import *
import binascii

def detect_collisions(pcap_file):
    packets = rdpcap(pcap_file)
    blocks = set()

    for pkt in packets:
        if pkt.haslayer(TLS):
            data = pkt[TLS].payload.load
            for i in range(0, len(data), 8):  # Check 64-bit blocks
                block = data[i:i+8]
                if block in blocks:
                    print(f"Collision detected for block: {binascii.hexlify(block)}")
                else:
                    blocks.add(block)

# Example usage:
detect_collisions('sweet32.pcap')
```